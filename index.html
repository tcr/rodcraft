<!DOCTYPE html>

<html>
<head>
<title>RodCraft (Bobcat)</title>
<style>

html, body, canvas { width: 100%; height: 100%; margin: 0; padding: 0; display: block; }
body { background: -webkit-linear-gradient(#aef, #57a); }
#cursor { border: 3px solid white; width: 20px; height: 20px; position: absolute; left: 50%; top: 50%; margin: -10px 0 0 -10px;}

p { position: absolute; left: 15px; bottom: 10px; font-size: 12px; font-family: Helvetica; color: white; background: rgba(0, 0, 0, 0.5); border-radius: 10px; padding: 10px 15px; max-width: 250px;  line-height: 1.3; }
tt { border: 1px solid #aaa; border-radius: 4px; padding: 1px 3px; font-size: 11px; background: rgba(255, 255, 255, 0.05); }
a { color: white; }

</style>
</head>
<body><div id="cursor"></div>
<p>
  <b>Instructions:</b> Click screen to capture mouse. Click and hold rod end to see where to connect next rod to. Hold down <tt>Shift</tt> to create diagonal rods.<br><br>
  <tt>W</tt> <tt>A</tt> <tt>S</tt> <tt>D</tt> &mdash; Move Character<br>
  <tt>Space</tt> &mdash; Jump<br>
  <tt>&uarr;</tt> <tt>&darr;</tt> <tt>&larr;</tt> <tt>&rarr;</tt> &mdash; Rotate Model (debug)<br><br>
  <a href="http://github.com/tcr/rodcraft">Rodcraft</a> is a game by <a href="http://github.com/tcr">Tim Cameron Ryan</a>
</p>
</body>

<script src="jquery.js"></script>
<script src="three.min.js"></script>
<script>

// camera resize: view-source:http://mrdoob.github.com/three.js/examples/webgl_interactive_cubes.html

function assoc (o, i) {
    var k, v;
    for (k in i) {
      v = i[k];
      o[k] = v;
    }
    return o;
  }

var camera, scene, projector, renderer;

var RODS = [], GRIPS = [], POINTED, SELECTED, TOPOINTS, POINTEDCUBE;
var construction, straightGrid, diagonalGrid;

var mouse = { x: 0, y: 0 };

var Controls, MouseEvent;

MouseEvent = {
  isLeftButton: function(event) {
    return event.which === 1;
  },
  isRightButton: function(event) {
    return event.which === 3;
  },
  isLeftButtonDown: function(event) {
    return event.button === 0 && this.isLeftButton(event);
  }
};

Controls = (function() {

  function Controls(object, domElement) {
    this.object = object;
    this.target = new THREE.Vector3(0, 0, 0);
    this.domElement = domElement || document;
    this.lookSpeed = 0.20;
    this.movementX = 0;
    this.movementY = 0;
    this.lat = 0;
    this.lon = -50;
    this.defineBindings();
  }

  Controls.prototype.defineBindings = function() {
    var _this = this;
    $(this.domElement).mousemove(function(e) {
      return _this.onMouseMove(e);
    });
    $(this.domElement).mousedown(function(e) {
      return _this.onMouseDown(e);
    });
    $(this.domElement).mouseup(function(e) {
      return _this.onMouseUp(e);
    });
    return $(this.domElement).mouseenter(function(e) {
      return _this.onMouserEnter(e);
    });
  };

  Controls.prototype.onMouserEnter = function(event) {
    if (!MouseEvent.isLeftButtonDown(event)) {
      return this.onMouseUp(event);
    }
  };

  Controls.prototype.onMouseDown = function(event) {
    if (!MouseEvent.isLeftButton(event)) {
      return;
    }
    if (this.domElement !== document) {
      this.domElement.focus();
    }
    this.anchorx = event.pageX;
    this.anchory = event.pageY;
    this.setMouse(event);
    this.mouseDragOn = true;
    return false;
  };

  Controls.prototype.onMouseUp = function(event) {
    this.mouseDragOn = false;
    return false;
  };

  Controls.prototype.setMouse = function(event) {
  };

  Controls.prototype.onMouseMove = function(event) {
    event = event.originalEvent;
    if (event.webkitMovementX || event.webkitMovementY) {
      this.movementX = event.webkitMovementX;
      this.movementY = event.webkitMovementY;
    }
  };

  Controls.prototype.halfCircle = Math.PI / 180;

  Controls.prototype.viewDirection = function() {
    return this.target.clone().subSelf(this.object.position);
  };

  Controls.prototype.move = function(newPosition) {
    this.object.position = newPosition;
    return this.updateLook();
  };

  Controls.prototype.updateLook = function() {
    var cos, p, phi, sin, theta;
    sin = Math.sin, cos = Math.cos;
    phi = (90 - this.lat) * this.halfCircle;
    theta = this.lon * this.halfCircle * 2;
    p = this.object.position;
    assoc(this.target, {
      x: p.x + 100 * sin(phi) * cos(theta),
      y: p.y + 100 * cos(phi),
      z: p.z + 100 * sin(phi) * sin(theta)
    });
    this.object.lookAt(this.target);
  };

  Controls.prototype.update = function() {
    var max, min;
    if (!this.movementX && !this.movementY) {
      return;
    }
    max = Math.max, min = Math.min;
    this.lon += (this.movementX) * this.lookSpeed;
    this.lat -= (this.movementY) * this.lookSpeed;
    this.movementX = 0;
    this.movementY = 0;
    this.lat = max(-85, min(85, this.lat));
    this.updateLook();
  };

  return Controls;

})();

window.MouseEvent = MouseEvent;

window.Controls = Controls;
  
function createCube (group, x, y, z, type) {
  var mesh = new THREE.Mesh(
    new THREE.CubeGeometry(
    GRIP_RADIUS*2,
    GRIP_RADIUS*2,
    GRIP_RADIUS*2),

    new THREE.MeshLambertMaterial({
      color: type ? 0x33FF99 : 0xFFFF00,
      transparent: true,
      opacity: 0.1
    }));
  mesh.position.x = x;
  mesh.position.y = y;
  mesh.position.z = z;

  mesh.type = type;

  group.add(mesh);
}

var ROD_LENGTH = 2.00, ROD_RADIUS = 0.05;
var GRIP_RADIUS = 0.30;

function createStraightGridControl () {
  var group = new THREE.Object3D();
  createCube(group, 0, 0, -ROD_LENGTH, 0);
  createCube(group, 0, 0, ROD_LENGTH, 0);
  createCube(group, 0, -ROD_LENGTH, 0, 0);
  createCube(group, 0, ROD_LENGTH, 0, 0);
  createCube(group, -ROD_LENGTH, 0, 0, 0);
  createCube(group, ROD_LENGTH, 0, 0, 0);
  return group;
}

function createDiagonalGridControl () {
  var group = new THREE.Object3D();
  createCube(group, 0, -ROD_LENGTH, -ROD_LENGTH, 1);
  createCube(group, 0, -ROD_LENGTH, +ROD_LENGTH, 1);
  createCube(group, 0, +ROD_LENGTH, -ROD_LENGTH, 1);
  createCube(group, 0, +ROD_LENGTH, +ROD_LENGTH, 1);
  createCube(group, -ROD_LENGTH, 0, -ROD_LENGTH, 1);
  createCube(group, -ROD_LENGTH, 0, +ROD_LENGTH, 1);
  createCube(group, +ROD_LENGTH, 0, -ROD_LENGTH, 1);
  createCube(group, +ROD_LENGTH, 0, +ROD_LENGTH, 1);
  createCube(group, -ROD_LENGTH, -ROD_LENGTH, 0, 1);
  createCube(group, +ROD_LENGTH, -ROD_LENGTH, 0, 1);
  createCube(group, -ROD_LENGTH, +ROD_LENGTH, 0, 1);
  createCube(group, +ROD_LENGTH, +ROD_LENGTH, 0, 1);
  return group;
}

function createConstruction (grip1, grip2) {

  var group = new THREE.Object3D();

  group.createGrip = function (x, y, z) {
    var existing = GRIPS.filter(function (g) {
      return g.position.x == x && g.position.y == y && g.position.z == z;
    });
    if (existing.length) {
      return existing[0];
    }

    // set up the sphere vars
    var radius = GRIP_RADIUS,
    segments = 16,
    rings = 16;

    // create a new mesh with
    // sphere geometry - we will cover
    // the sphereMaterial next!
    var mesh = new THREE.Mesh(
      new THREE.SphereGeometry(
      radius,
      segments,
      rings),

      new THREE.MeshLambertMaterial({
        color: 0x3399FF,
        transparent: true,
        opacity: 0
      }));

    mesh.position.x = x;
    mesh.position.y = y;
    mesh.position.z = z;

    group.add(mesh);
    GRIPS.push(mesh);

    return mesh;
  }

  group.createRod = function (from, to, type) {
    var ROD_LENGTH = from.position.distanceTo(to.position);

    var geometry = new THREE.CubeGeometry(ROD_LENGTH + ROD_RADIUS*2, ROD_RADIUS*2, ROD_RADIUS*2 );
    var material = new THREE.MeshLambertMaterial({
      color: type ? 0xFFFF00 : 0x0000FF
    });
    var rod = new THREE.Mesh( geometry, material );
    rod.position.x = (from.position.x + to.position.x) / 2;
    rod.position.y = (from.position.y + to.position.y) / 2;
    rod.position.z = (from.position.z + to.position.z) / 2;

    var doX = 0, doY = 0, doZ = 0;
    if ((from.position.x|0) != (to.position.x|0)) {
      console.log('x');
      doX = from.position.x < to.position.x ? -1 : 1;
    }
    if ((from.position.y|0) != (to.position.y|0)) {
      console.log('y');
      doY = from.position.y < to.position.y ? -1 :1;
    }
    if ((from.position.z|0) != (to.position.z|0)) {
      console.log('z');
      doZ = from.position.z < to.position.z ? -1 : 1;
    }

    var vec = new THREE.Vector3(doX, doY, doZ);
    rod.rotation.y = -Math.atan2(vec.z, vec.x);
    rod.rotation.z = Math.atan2(vec.y, Math.sqrt(vec.x*vec.x + vec.z*vec.z));

    RODS.push(rod);
    group.add(rod);
    return rod;
  }

  var grip1 = group.createGrip(-ROD_LENGTH/2, 0, 0)
  var grip2 = group.createGrip(ROD_LENGTH/2, 0, 0);

  group.createRod(grip1, grip2);

  return group;
}

function createRodBetween(from, to) {
  var rod = createRod(from);
  //var fromp = from.matrixWorld.multiplyVector3(new THREE.Vector3());
  var top = to.matrixWorld.multiplyVector3(new THREE.Vector3());
  RODS.push(rod);
  scene.add(rod);
  return rod;
}

function destroyRod (rod) {
  RODS = RODS.filter(function (a) {
    return a != rod;
  });
  construction.remove(rod);
}

function destroyGrip (grip) {
  GRIPS = GRIPS.filter(function (a) {
    return a != grip;
  });
  construction.remove(grip);
}

function init () {
  // Camera
  camera = new THREE.PerspectiveCamera(
    50,
    window.innerWidth / window.innerHeight,
    1, 10000
  );
  camera.position.z = 8;

  // Build scene.
  scene = new THREE.Scene();

  // Add rod
  construction = createConstruction();
  construction.position.y -= 1;
  scene.add(construction);

  straightGrid = createStraightGridControl();
  diagonalGrid = createDiagonalGridControl();

  // Add point light
  var pointLight = new THREE.PointLight(0xFFFFFF);
  // set its position
  pointLight.position.x = 0;
  pointLight.position.y = 0;
  pointLight.position.z = 500;
  // add to the scene
  scene.add(pointLight);

  // Projector
  projector = new THREE.Projector();

  controls = new Controls(camera);

  // Render
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize( window.innerWidth, window.innerHeight );

  // Insert element.
  document.body.appendChild( renderer.domElement );

}

function animate() {
  requestAnimationFrame(animate);
  render();
}

var KEY_DOWN = 40;
var KEY_UP = 38;
var KEY_LEFT = 37;
var KEY_RIGHT = 39;
var KEY_W = 87;
var KEY_S = 83;
var KEY_A = 65;
var KEY_D = 68;
var KEY_R = 82;
var KEY_F = 70;
var KEY_SPACE = 32;
var KEY_SHIFT = 16;

var ACCEL_GRAV = -0.004, accel_y = 0;

function render() {

  if (document.webkitPointerLockElement == document.body) {
    if (keysdown[KEY_DOWN])   construction.rotation.x += 0.02;
    if (keysdown[KEY_UP])     construction.rotation.x -= 0.02;
    if (keysdown[KEY_LEFT])   construction.rotation.y -= 0.02;
    if (keysdown[KEY_RIGHT])  construction.rotation.y += 0.02;

    if (keysdown[KEY_W])      camera.position.z -= 0.05;
    if (keysdown[KEY_S])      camera.position.z += 0.05;
    if (keysdown[KEY_A])      camera.position.x -= 0.02;
    if (keysdown[KEY_D])      camera.position.x += 0.02;

    if (keysdown[KEY_SPACE] && accel_y == 0)  accel_y = 0.170;

    controls.update();

    camera.position.y += accel_y;
    accel_y += ACCEL_GRAV;
    if (camera.position.y < 0) {
      camera.position.y = 0;
      accel_y = 0;
    }

    // Intersections.
    if (controls.target) {
      var vector = controls.target.clone(); //new THREE.Vector3( mouse.x, mouse.y, 1 );
      //projector.unprojectVector( vector, camera );
      //var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
      var raycaster = new THREE.Raycaster( camera.position, vector.subSelf(camera.position).normalize() );


      var intersects = raycaster.intersectObjects( GRIPS );
      if (intersects.length) {
        if (POINTED != intersects[0].object) {
          if (POINTED) {
            POINTED.material.opacity = POINTED == SELECTED ? 0.3 : 0;
          }

          POINTED = intersects[ 0 ].object;
          POINTED.material.opacity = POINTED == SELECTED ? 0.3 : 0.15;
        }
      } else {
        if (POINTED) {
          POINTED.material.opacity = POINTED == SELECTED ? 0.3 : 0;
        }
        POINTED = null;
      }

      if (tmpgridcontrol) {
        var intersects = raycaster.intersectObjects( tmpgridcontrol.children );
        if (intersects.length) {
          if (POINTEDCUBE != intersects[0].object) {
            if (POINTEDCUBE) {
              POINTEDCUBE.material.opacity = 0.1;
            }

            POINTEDCUBE = intersects[ 0 ].object;
            POINTEDCUBE.material.opacity = 0.4;
          }
        } else {
          if (POINTEDCUBE) {
            POINTEDCUBE.material.opacity = 0.1;
          }
          POINTEDCUBE = null;
        }
      }
    }
  }

  renderer.render(scene, camera);
}


var isMouseDown = false;


var tmprod, tmpgrip, tmppointed, tmpgridcontrol;
$(document).on('mousemove', function ( event ) {
  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

  if (tmppointed != POINTEDCUBE && tmppointed) {
    destroyRod(tmprod);
    destroyGrip(tmpgrip);
    tmprod = tmpgrip = tmppointed = null;
  }
  if (POINTEDCUBE && !tmppointed) {
    tmppointed = POINTEDCUBE;
    tmpgrip = construction.createGrip(
      SELECTED.position.x + POINTEDCUBE.position.x,
      SELECTED.position.y + POINTEDCUBE.position.y,
      SELECTED.position.z + POINTEDCUBE.position.z);
    tmprod = construction.createRod(SELECTED, tmpgrip, tmppointed.type);
    console.log('connect', tmprod);
  } 
  
  return false;
});


$(document).on('mouseup', function () {
  isMouseDown = false;
  if (SELECTED) {
    SELECTED.material.opacity = 0;
    SELECTED = null;
  }
  if (tmpgridcontrol) {
    console.log('remove');
    construction.remove(tmpgridcontrol);
  }
  tmprod = tmpgrip = tmpgridcontrol = null;
});

$(document).on('mousedown', function () {
  isMouseDown = true;

  if (POINTED) {
    if (SELECTED) {
      SELECTED.material.opacity = 0;
    }
    SELECTED = POINTED;
    SELECTED.material.opacity = 0.5;

    tmpgridcontrol = keysdown[KEY_SHIFT] ? diagonalGrid : straightGrid;
    construction.add(tmpgridcontrol);
    tmpgridcontrol.position.copy(SELECTED.position);
  }
});

var keysdown = {};
$(document).on('keydown', function (e) {
  keysdown[e.which] = true;
  if (e.which == KEY_SHIFT && tmpgridcontrol) {
    diagonalGrid.position.copy(tmpgridcontrol.position);
    construction.remove(tmpgridcontrol);
    construction.add(diagonalGrid);
    tmpgridcontrol = diagonalGrid;
    console.log(diagonalGrid.position);
  }
});
$(document).on('keyup', function (e) {
  delete keysdown[e.which];
  if (e.which == KEY_SHIFT && tmpgridcontrol) {
    straightGrid.position.copy(tmpgridcontrol.position);
    construction.remove(tmpgridcontrol);
    construction.add(straightGrid);
    tmpgridcontrol = straightGrid;
  }
});
$(document).on('focus', function (e) {
  keysdown = {};
});

$(document).on('click', function () {
  document.body.webkitRequestPointerLock();
});


init();
animate();
</script>

</html>
