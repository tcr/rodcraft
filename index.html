<!DOCTYPE html>

<html>
<head>
<title>RodCraft (Bobcat)</title>
<style>

html, body, canvas { width: 100%; height: 100%; margin: 0; padding: 0; display: block; }
body { background: -webkit-linear-gradient(#eee, #aaa); }

</style>
</head>
<body></body>

<script src="jquery.js"></script>
<script src="three.min.js"></script>
<script>

// camera resize: view-source:http://mrdoob.github.com/three.js/examples/webgl_interactive_cubes.html

var camera, scene, projector, renderer;

var RODS = [], GRIPS = [], POINTED, SELECTED, TOPOINTS, POINTEDCUBE;
var construction;

var mouse = { x: 0, y: 0 };

function createConstruction (grip1, grip2) {

  var ROD_LENGTH = 200, ROD_RADIUS = 5;

  var group = new THREE.Object3D();

  function createCube (group, CUBES, x, y, z) {
    var mesh = new THREE.Mesh(
      new THREE.CubeGeometry(
      25,
      25,
      25),

      new THREE.MeshLambertMaterial({
        color: 0x33FF99,
        transparent: true,
        opacity: 0
      }));
    mesh.position.x = x;
    mesh.position.y = y;
    mesh.position.z = z;

    CUBES.push(mesh);
  }

  group.createGrip = function (x, y, z) {
    var existing = GRIPS.filter(function (g) {
      return g.position.x == x && g.position.y == y && g.position.z == z;
    });
    if (existing.length) {
      return existing[0];
    }

    var CUBES = [];
    createCube(this, CUBES, 0 + x, 0 + y, -ROD_LENGTH + z);
    createCube(this, CUBES, 0 + x, 0 + y, ROD_LENGTH + z);
    createCube(this, CUBES, 0 + x, -ROD_LENGTH + y, 0 + z);
    createCube(this, CUBES, 0 + x, ROD_LENGTH + y, 0 + z);
    createCube(this, CUBES, -ROD_LENGTH + x, 0 + y, 0 + z);
    createCube(this, CUBES, ROD_LENGTH + x, 0 + y, 0 + z);

    // set up the sphere vars
    var radius = 20,
    segments = 16,
    rings = 16;

    // create a new mesh with
    // sphere geometry - we will cover
    // the sphereMaterial next!
    var mesh = new THREE.Mesh(
      new THREE.SphereGeometry(
      radius,
      segments,
      rings),

      new THREE.MeshLambertMaterial({
        color: 0x3399FF,
        transparent: true,
        opacity: 0
      }));

    mesh.position.x = x;
    mesh.position.y = y;
    mesh.position.z = z;

    mesh.toggleCubes = function (flag) {
      TOPOINTS = CUBES;
      CUBES.forEach(function (cube) {
        flag ? group.add(cube) : group.remove(cube);
        cube.material.opacity = flag ? 0.2 : 0;
      });
    }

    group.add(mesh);
    GRIPS.push(mesh);

    return mesh;
  }

  group.createRod = function (from, to) {
    var geometry = new THREE.CubeGeometry(ROD_LENGTH + ROD_RADIUS*2, ROD_RADIUS*2, ROD_RADIUS*2 );
    var material = new THREE.MeshLambertMaterial(
      {
        color: 0xFF3333
      });
    var rod = new THREE.Mesh( geometry, material );
    rod.position.x = (from.position.x + to.position.x) / 2;
    rod.position.y = (from.position.y + to.position.y) / 2;
    rod.position.z = (from.position.z + to.position.z) / 2;
    if ((from.position.x|0) != (to.position.x|0)) {
      console.log('x');
      rod.rotation.x = Math.PI/2 * (from.position.x < to.position.x ? -1 : 1);
    }
    if ((from.position.y|0) != (to.position.y|0)) {
      console.log('y');
      rod.rotation.z = Math.PI/2 * (from.position.z < to.position.z ? -1 : 1);
    }
    if ((from.position.z|0) != (to.position.z|0)) {
      console.log('z');
      rod.rotation.y = Math.PI/2 * (from.position.y < to.position.y ? -1 : 1);
    }
    console.log(rod.position, from.position.y/to.position.y);
    RODS.push(rod);
    group.add(rod);
    return rod;
  }

  var grip1 = group.createGrip(-ROD_LENGTH/2, 0, 0)
  var grip2 = group.createGrip(ROD_LENGTH/2, 0, 0);

  group.createRod(grip1, grip2);

  return group;
}

function createRodBetween(from, to) {
  var rod = createRod(from);
  //var fromp = from.matrixWorld.multiplyVector3(new THREE.Vector3());
  var top = to.matrixWorld.multiplyVector3(new THREE.Vector3());
  RODS.push(rod);
  scene.add(rod);
  return rod;
}

function destroyRod (rod) {
  RODS = RODS.filter(function (a) {
    return a != rod;
  });
  construction.remove(rod);
}

function init () {
  // Camera
  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    1, 10000
  );
  camera.position.z = 500;

  // Build scene.
  scene = new THREE.Scene();

  // Add rod
  construction = createConstruction();
  scene.add(construction);

  // Add point light
  var pointLight = new THREE.PointLight(0xFFFFFF);
  // set its position
  pointLight.position.x = 0;
  pointLight.position.y = 0;
  pointLight.position.z = 500;
  // add to the scene
  scene.add(pointLight);

  // Projector
  projector = new THREE.Projector();

  // Render
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize( window.innerWidth, window.innerHeight );

  // Insert element.
  document.body.appendChild( renderer.domElement );

}

function animate() {
  requestAnimationFrame(animate);
  render();
}

function render() {

  //group.rotation.x += 0.01;
  //group.rotation.z += 0.02;

  // Intersections.
  var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
  projector.unprojectVector( vector, camera );
  var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );

  var intersects = raycaster.intersectObjects( GRIPS );
  if (intersects.length) {
    if (POINTED != intersects[0].object) {
      if (POINTED) {
        POINTED.material.opacity = POINTED == SELECTED ? 0.3 : 0;
      }

      POINTED = intersects[ 0 ].object;
      POINTED.material.opacity = POINTED == SELECTED ? 0.3 : 0.15;
    }
  } else {
    if (POINTED) {
      POINTED.material.opacity = POINTED == SELECTED ? 0.3 : 0;
    }
    POINTED = null;
  }

  if (TOPOINTS) {
    var intersects = raycaster.intersectObjects( TOPOINTS );
    if (intersects.length) {
      if (POINTEDCUBE != intersects[0].object) {
        if (POINTEDCUBE) {
          POINTEDCUBE.material.opacity = 0.2;
        }

        POINTEDCUBE = intersects[ 0 ].object;
        POINTEDCUBE.material.opacity = 0.5;
      }
    } else {
      if (POINTEDCUBE) {
        POINTEDCUBE.material.opacity = 0.2;
      }
      POINTEDCUBE = null;
    }
  }

  renderer.render(scene, camera);
}


var isMouseDown = false;


var tmprod;
$(document).on('mousemove', function ( event ) {
  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

  if (POINTEDCUBE && isMouseDown && !tmprod) {
    POINTEDCUBE = construction.createGrip(POINTEDCUBE.position.x, POINTEDCUBE.position.y, POINTEDCUBE.position.z);
    tmprod = construction.createRod(SELECTED, POINTEDCUBE);
    console.log('connect', tmprod);
  } else if (!POINTEDCUBE && tmprod) {
    destroyRod(tmprod);
    tmprod = null;
  }
  
  return false;
});


$(document).on('mouseup', function () {
  isMouseDown = false;
  if (SELECTED) {
    SELECTED.toggleCubes(false);
    SELECTED.material.opacity = 0;
    SELECTED = null;
  }
  tmprod = null;
});

$(document).on('mousedown', function () {
  isMouseDown = true;

  if (POINTED) {
    if (SELECTED) {
      SELECTED.material.opacity = 0;
    }
    SELECTED = POINTED;
    SELECTED.material.opacity = 0.5;
    SELECTED.toggleCubes(true);
  }
});

$(document).on('keydown', function (e) {
  console.log(e.which);
  switch (e.which) {
    case 38: camera.position.z += -12; break;
    case 40: camera.position.z += +12; break;
    case 39: camera.position.x -= 12; break;
    case 37: camera.position.x += 12; break;
  }
})

init();
animate();
</script>

</html>
